export const BUFF_COLOR_COUNT = 256 * 256;
export const BUFF_COLOR_VALUES_COUNT = 4;
export const BUFF_DATA_COUNT = 1024 * 1024;
export const BUFF_DATA_ELEMENTS_PER_TILE = 4;
export const BUFF_DATA_VALUES_COUNT = 4 * BUFF_DATA_ELEMENTS_PER_TILE;
/**
 * 0 
 */

const REGE_IMPORT_VALUES_FROM_HEX_COLOR = /([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})/;

export const TILE_TYPE_VOID = 0;            // 00
export const TILE_TYPE_VILLAGE = 1;         // 01
export const TILE_TYPE_BORDER = 2;          // 10
export const TILE_TYPE_BORDER_WATER = 3;    // 11

import {
    COLOR_INDEX_BACKGROUND,
    COLOR_INDEX_BORDER_PROVINCE,
    COLOR_INDEX_BORDER_CONTINENT,
    COLOR_INDEX_HOVER_GROUP,
    COLOR_INDEX_HOVER_ITEM,
    COLOR_INDEX_VILLAGE_BARBARIAN,
    COLOR_INDEX_VILLAGE_PLAYER
} from 'canvas/data/mapColors';
import debug from 'debug';

/******************************/

const debugLog = debug('app:canvas:buffers');

/******************************/

export default class BuffersManager {
    protected dataBuffer: Uint8Array;
    protected colorBuffer: Uint8Array;
    protected nextSlotIndex: number = 0;
    protected nextUserSlotIndex: number = 0;
    getNextUserSlotIndex() {return this.nextUserSlotIndex;}

    init(): void {
        this.createDataBuffer();
        this.createColorBuffer();
    }

    /******************************/
    
    getIntColorBackground() {
        return this.getIntColorSlot(COLOR_INDEX_BACKGROUND);
    }
    getIntColorProvinceBorder() {
        return this.getIntColorSlot(COLOR_INDEX_BORDER_PROVINCE);
    }
    getIntColorContinentBorder() {
        return this.getIntColorSlot(COLOR_INDEX_BORDER_CONTINENT);
    }
    getIntColorItemHover() {
        return this.getIntColorSlot(COLOR_INDEX_HOVER_ITEM);
    }
    getIntColorGroupHover() {
        return this.getIntColorSlot(COLOR_INDEX_HOVER_GROUP);
    }
    getIntColorPlayerVillage() {
        return this.getIntColorSlot(COLOR_INDEX_VILLAGE_PLAYER);
    }
    getIntColorBarbarianVillage() {
        return this.getIntColorSlot(COLOR_INDEX_VILLAGE_BARBARIAN);
    }
    getIntColorSlot(slot) {
        let colorX = slot % 255,
            colorY = Math.floor(slot / 255);
        return  (colorX << 24) |
                (colorY << 16) | 0xff00;

    }
    getIntColorBySlot(slot) {
        let index = this.getColorIndex(slot);
        return  (this.colorBuffer[ index + 0 ] << 24) |
                (this.colorBuffer[ index + 1 ] << 16) |
                (this.colorBuffer[ index + 2 ] <<  8) | 0xff;
    }

    /******************************/

    protected createDataBuffer(): Uint8Array {
        let dataBuffer = new Uint8Array(BUFF_DATA_COUNT * BUFF_DATA_VALUES_COUNT);

        for (var i = 0; i < BUFF_DATA_COUNT * BUFF_DATA_VALUES_COUNT; i+= BUFF_DATA_VALUES_COUNT) {
            dataBuffer[ i + 0 ] = COLOR_INDEX_BACKGROUND;
            dataBuffer[ i + 1 ] = 0;
            dataBuffer[ i + 2 ] = TILE_TYPE_VOID;
            dataBuffer[ i + 3 ] = 0;
            dataBuffer[ i + 4 ] = 0;
            dataBuffer[ i + 5 ] = 0;
        }

        return this.dataBuffer = dataBuffer;
    }

    protected createColorBuffer(): Uint8Array {
        this.colorBuffer = new Uint8Array(BUFF_COLOR_COUNT * BUFF_COLOR_VALUES_COUNT);
        this.initDefaultColors();

        this.nextUserSlotIndex = this.nextSlotIndex;

        return this.colorBuffer;
    }

    protected initDefaultColors(): void {
        this.addColor('#004000ff'); // background
        this.addColor('#888888ff'); // border
        this.addColor('#ffff00ff'); // river
        this.addColor('#003000ff'); // player village
        this.addColor('#005000ff'); // barbarian village
        this.addColor('#ffffffff'); // hover
        this.addColor('#999999ff'); // hover group
    }

    /******************************/

    /**
     * @param color Color in hex: '#aabbcc'
     * @return slot number
     */
    addColor(
        color: string
    ): number {
        let slot = Math.min(this.nextSlotIndex++, BUFF_COLOR_COUNT - 1);

        this.setColor(slot, color);

        return slot;
    }

    getColorIndex(
        slot: number
    ): number {
        let validSlot = Math.max(0, Math.min(slot, BUFF_COLOR_COUNT - 1)),
            index = validSlot * BUFF_COLOR_VALUES_COUNT;

        return index;
    }

    getColor (
        slot: number
    ): string {
        let index = this.getColorIndex(slot);

        return `#${ Buffer.from([
            this.colorBuffer[ index + 0 ],
            this.colorBuffer[ index + 1 ],
            this.colorBuffer[ index + 2 ]
        ]).toString('hex') }`;
    }

    setColor(
        slot: number,
        color: string
    ): void {
        if (!color) return;

        let validSlot = Math.max(0, Math.min(slot, BUFF_COLOR_COUNT - 1)),
            index = validSlot * BUFF_COLOR_VALUES_COUNT,
            colorValues = color.match(REGE_IMPORT_VALUES_FROM_HEX_COLOR);

        if (colorValues.length !== 4) {
            throw new Error('TODO: invalid color format');
        }

        this.colorBuffer[ index + 0 ] = parseInt(colorValues[1], 16);
        this.colorBuffer[ index + 1 ] = parseInt(colorValues[2], 16);
        this.colorBuffer[ index + 2 ] = parseInt(colorValues[3], 16);
        this.colorBuffer[ index + 3 ] = parseInt(colorValues[4], 16) || 255;
    }

    coord2Index(
        x: number,
        y: number
    ) {
        return y * 1024 * BUFF_DATA_VALUES_COUNT + x * BUFF_DATA_VALUES_COUNT;
    }

    // color

    // tileSetBgSlot(
    //     x: number,
    //     y: number,
    //     slot: number
    // ): void {
    //     this.tileSetBgSlotByIndex(
    //         this.coord2Index(x, y),
    //         slot
    //     );
    // }

    // tileSetBgSlotByIndex(
    //     index: number,
    //     slot: number
    // ): void {
    //     let colorX = slot % 255,
    //         colorY = Math.floor(slot / 255);

    //     this.dataBuffer[ index + 0 ] = colorX;
    //     this.dataBuffer[ index + 1 ] = colorY;
    // }

    // tileSetColorSlot(
    //     x: number,
    //     y: number,
    //     slot: number
    // ): void {
    //     this.tileSetColorByIndex(
    //         this.coord2Index(x, y),
    //         slot
    //     );
    // }

    // tileSetColorByIndex(
    //     index: number,
    //     slot: number
    // ): void {
    //     let colorX = slot % 255,
    //         colorY = Math.floor(slot / 255);

    //     this.dataBuffer[ index + 3 ] = colorX;
    //     this.dataBuffer[ index + 4 ] = colorY;
    // }
        // color1
        tileSetColor1(
            x: number,
            y: number,
            intColor: number
        ): void {
            this.tileSetColor1ByIndex(
                this.coord2Index(x, y),
                intColor
            );
        }
        tileSetColor1ByIndex(
            index: number,
            intColor: number
        ): void {
            const slot = 1 * 4;
            this.dataBuffer[ index + slot + 0 ] = (intColor >> 24) & 0xff;
            this.dataBuffer[ index + slot + 1 ] = (intColor >> 16) & 0xff;
            this.dataBuffer[ index + slot + 2 ] = (intColor >>  8) & 0xff;
            this.dataBuffer[ index + slot + 3 ] = (intColor >>  0) & 0xff;
        }

        // color2
        tileSetColor2(
            x: number,
            y: number,
            intColor: number
        ): void {
            this.tileSetColor2ByIndex(
                this.coord2Index(x, y),
                intColor
            );
        }
        tileSetColor2ByIndex(
            index: number,
            intColor: number
        ): void {
            const slot = 2 * 4;
            this.dataBuffer[ index + slot + 0 ] = (intColor >> 24) & 0xff;
            this.dataBuffer[ index + slot + 1 ] = (intColor >> 16) & 0xff;
            this.dataBuffer[ index + slot + 2 ] = (intColor >>  8) & 0xff;
            this.dataBuffer[ index + slot + 3 ] = (intColor >>  0) & 0xff;
        }

        // color3
        tileSetColor3(
            x: number,
            y: number,
            intColor: number
        ): void {
            this.tileSetColor3ByIndex(
                this.coord2Index(x, y),
                intColor
            );
        }
        tileSetColor3ByIndex(
            index: number,
            intColor: number
        ): void {
            const slot = 3 * 4;
            this.dataBuffer[ index + slot + 0 ] = (intColor >> 24) & 0xff;
            this.dataBuffer[ index + slot + 1 ] = (intColor >> 16) & 0xff;
            this.dataBuffer[ index + slot + 2 ] = (intColor >>  8) & 0xff;
            this.dataBuffer[ index + slot + 3 ] = (intColor >>  0) & 0xff;
        }

    // type

    tileGetType(
        x: number,
        y: number,
    ): number {
        return this.tileGetTypeByIndex(
            this.coord2Index(x, y)
        );
    }
    tileGetTypeByIndex(
        index: number
    ): number {
        return this.dataBuffer[ index + 2 ];
    }
    tileSetType(
        x: number,
        y: number,
        type: number
    ): void {
        this.tileSetTypeByIndex(
            this.coord2Index(x, y),
            type
        );
    }
    tileSetTypeByIndex(
        index: number,
        type: number
    ): void {
        this.dataBuffer[ index + 2 ] = type;

        switch (type) {
            case TILE_TYPE_BORDER_WATER:
                this.dataBuffer[ index + 3 ] = COLOR_INDEX_BORDER_PROVINCE;
                this.dataBuffer[ index + 4 ] = 0;
                break;
            case TILE_TYPE_BORDER:
                this.dataBuffer[ index + 3 ] = COLOR_INDEX_BORDER_CONTINENT;
                this.dataBuffer[ index + 4 ] = 0;
                break;
        }
    }

    /******************************/

    getDataBuffer(): Uint8Array {
        return this.dataBuffer;
    }

    getColorBuffer(): Uint8Array {
        return this.colorBuffer;
    }
}