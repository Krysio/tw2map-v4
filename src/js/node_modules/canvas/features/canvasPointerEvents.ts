import State from "canvas/data/State";
import Renderer from "canvas/Renderer";
import Events from "canvas/Events";
import { Commands } from "canvas";

/******************************/

export default function featureCanvasPointerEvents(
    element: HTMLElement,
    renderer: Renderer,
    state: State,
    events: Events,
    commands: Commands
): void {
    let mouseState = {
        prev: [0, 0],
        prevTile: [0, 0],
        click: false,
        move: false
    };

    element.addEventListener('mousemove', (e: MouseEvent) => {
        if (mouseState.click) {
            let diffX = mouseState.prev[0] - e.offsetX,
                diffY = mouseState.prev[1] - e.offsetY;

            if (mouseState.move === false
                && (
                    diffX > 5 || diffX < -5
                    || diffY > 5 || diffY < -5
                )
            ) {
                mouseState.move = true;
                events.emit('changed canvas/move', true);
            }

            if (mouseState.move) {
                commands.setPositionAddPixels(diffX, diffY);

                mouseState.prev[0] = e.offsetX;
                mouseState.prev[1] = e.offsetY;
            }
        } else {
            commands.setHoverScreenPx(e.offsetX, e.offsetY);
        }
    }, false);

    element.addEventListener('mousedown', (e: MouseEvent) => {
        mouseState.prev[0] = e.offsetX;
        mouseState.prev[1] = e.offsetY;
        mouseState.click = true;
    }, false);

    element.addEventListener('mouseup', (e: MouseEvent) => {
        if (mouseState.move) {
            events.emit('changed canvas/move', false);
        } else if (mouseState.click) {
            let [ x, y ] = mouseState.prevTile;

            events.emit('changed clicked/tile', { x, y });
        }

        mouseState.click = false;
        mouseState.move = false;
    }, false);

    element.addEventListener('mouseenter', (e: MouseEvent) => {
        events.emit('canvas/enter', null);
    }, false);

    element.addEventListener('mouseleave', (e: MouseEvent) => {
        if (mouseState.move) {
            events.emit('changed canvas/move', false);
        }

        events.emit('canvas/leave', null);
        mouseState.click = false;
        mouseState.move = false;
    }, false);

    // wheel - zoom
    let wheelEvent = "onwheel" in HTMLDivElement.prototype
        ? "wheel"
        : document['onmousewheel'] !== undefined
            ? "mousewheel"
            : "DOMMouseScroll";

    element.addEventListener(wheelEvent, (e: MouseEvent) => {
        if (e['deltaY'] < 0) {
            commands.setMultipleSize(1 + 0.1, true);
        } else {
            commands.setMultipleSize(1 - 0.1, true);
        }
    }, {
        capture: false,
        passive: true
    });

    // touch

    let touchState = {
        touch: false,
        multi: false,
        move: false,
        prev: {
            a: [0, 0],
            b: [0, 0]
        }
    };

    element.addEventListener("touchmove", (e: TouchEvent) => {
        let touch = e.touches[0];
        let secondTouch = e.touches[1];

        if (touchState.multi, secondTouch) {
            let prevValue
                = Math.pow(touchState.prev.a[0] - touchState.prev.b[0], 2)
                + Math.pow(touchState.prev.a[1] - touchState.prev.b[1], 2);
            let currentValue
                = Math.pow(touch.clientX - secondTouch.clientX, 2)
                + Math.pow(touch.clientY - secondTouch.clientY, 2);

            commands.setMultipleSize((currentValue / prevValue) || 1);

            touchState.prev.a[0] = touch.clientX;
            touchState.prev.a[1] = touch.clientY;
            touchState.prev.b[0] = secondTouch.clientX;
            touchState.prev.b[1] = secondTouch.clientY;
        } else if (touchState.touch) {
            let diffX = touchState.prev.a[0] - touch.clientX,
                diffY = touchState.prev.a[1] - touch.clientY;

            if (touchState.move === false
                && (
                    diffX > 5 || diffX < -5
                    || diffY > 5 || diffY < -5
                )
            ) {
                touchState.move = true;
                events.emit('changed canvas/move', true);
            }

            if (touchState.move) {
                commands.setPositionAddPixels(diffX, diffY);

                touchState.prev.a[0] = touch.clientX;
                touchState.prev.a[1] = touch.clientY;
            }
        }

        e.preventDefault(); // android chrome :/
    }, {
        capture: false,
        passive: true
    });
    element.addEventListener("touchstart", (e: TouchEvent) => {
        touchState.touch = true;

        if (e.touches.length > 1) {
            let touch = e.touches[1];

            touchState.multi = true;
            touchState.prev.b[0] = touch.clientX;
            touchState.prev.b[1] = touch.clientY;
        } else {
            let touch = e.touches[0];

            touchState.prev.a[0] = touch.clientX;
            touchState.prev.a[1] = touch.clientY;
        }
    }, {
        capture: false,
        passive: true
    });
    element.addEventListener("touchend", (e: TouchEvent) => {
        if (e.touches.length === 2) {
            touchState.multi = false;
        } else {
            if (touchState.move) {
                events.emit('changed canvas/move', false);
            }
            touchState.touch = false;
            touchState.move = false;
        }
    }, {
        capture: false,
        passive: true
    });
    element.addEventListener("touchcancel", (e: TouchEvent) => {
        if (e.touches.length === 2) {
            touchState.multi = false;
        } else {
            if (touchState.move) {
                events.emit('changed canvas/move', false);
            }
            touchState.touch = false;
            touchState.move = false;
        }
    }, {
        capture: false,
        passive: true
    });
}