import { Context } from "canvas";
import MapItem from "data/data/Item";
import Village from "data/data/Village";
import Character from "data/data/Character";
import debug from 'debug';
import {
    COLOR_INDEX_VILLAGE_BARBARIAN,
    COLOR_INDEX_VILLAGE_PLAYER
} from "canvas/data/mapColors";

/******************************/

const debugLog = debug('app:canvas:featurePalette');

/******************************/

type ItemPalette = {
    uuid: string,
    item: MapItem,
    color: {
        uuid: string,
        index: string,
        value: string
    }
};

/******************************/

export default function featurePalette(
    refContext: any
) {
    const context = refContext as Context;

    /******************************/

    function sortColors(
        a: Color,
        b: Color
    ) {
        if (a.index === b.index) {
            return 0;
        } else if (a.index < b.index) {
            return 1;
        } else {
            return -1;
        }
    }

    class Color {
        slot: number;
        active = true;

        constructor(
            public uuid: string,
            public value: string,
            public index: string
        ) {
            this.slot = context.buffersManager.addColor(value);
        }
    }

    class ColorBox {
        colorList: Color[] = [];

        constructor(
            public item: MapItem
        ) {}

        addColor(
            color: Color
        ) {
            const index = this.colorList.indexOf(color);

            if (index === -1) {
                this.colorList.push(color);
            }

            this.colorList.sort(sortColors);
        }

        get() {
            if (this.colorList.length && this.colorList[0].active === false) {
                for (let i = 0; i < this.colorList.length; i++) {
                    if (this.colorList[ i ].active === false) {
                        this.colorList.splice(i, 1);
                        i--;
                    }
                }
                this.colorList.sort(sortColors);
            }

            return this.colorList[0] || null;
        }
    }

    class Palette {
        village = {} as {[key: number]: ColorBox};
        character = {} as {[key: number]: ColorBox};
        tribe = {} as {[key: number]: ColorBox};
        map_uuid_color = {} as {[key: string]: Color};

        /******************************/
    
        getColor(
            uuid: string
        ) {
            if (uuid in this.map_uuid_color) {
                return this.map_uuid_color[ uuid ];
            }
            return null;
        }
    
        update(
            palette: ItemPalette[]
        ) {
            // disable all colors
            for (let uuid in this.map_uuid_color) {
                this.map_uuid_color[ uuid ].active = false;
            }
    
            const dirtyVillages = [] as Village[];
    
            for (let itemPalette of palette) {
                const { id, mapItemType: type } = itemPalette.item;
    
                if (itemPalette.color === null) {
                    const villageList = itemPalette.item.getVillages();
                    for (let village of villageList) {
                        const index = dirtyVillages.indexOf(village);
    
                        if (index === -1) {
                            dirtyVillages.push(village);
                        }
                    }
                    continue;
                }
    
                let color = this.getColor(itemPalette.color.uuid);
    
                if (color === null) {
                    color = new Color(
                        itemPalette.color.uuid,
                        itemPalette.color.value,
                        itemPalette.color.index
                    );
                    this.map_uuid_color[ itemPalette.color.uuid ] = color;
                } else {
                    color.active = true;
                    color.value = itemPalette.color.value;
                    color.index = itemPalette.color.index;
                    context.buffersManager.setColor(color.slot, color.value);
                }
    
                if (type in this) {
                    if (!(itemPalette.item.id in this[ type ])) {
                        this[ type ][ id ] = new ColorBox(itemPalette.item);
                    }
                    this[ type ][ id ].addColor(color);
    
                    const villageList = itemPalette.item.getVillages();
                    for (let village of villageList) {
                        const index = dirtyVillages.indexOf(village);
    
                        if (index === -1) {
                            dirtyVillages.push(village);
                        }
                    }
                }
            }
    
            for (let village of dirtyVillages) {
                context.buffersManager.tileSetColorSlot(
                    village.x,
                    village.y,
                    context.getVillageSlotColor(village)
                );
            }
        }
    
        getVillageSlotColor(
            village: Village
        ) {
            let colorBox: ColorBox;
            let slotColor: Color = null;
    
            colorBox = this.village[ village.id ];
            if (colorBox) {
                slotColor = colorBox.get();
            }
            if (slotColor === null && village.character) {
                colorBox = this.character[ village.character.id ];
    
                if (colorBox) {
                    slotColor = colorBox.get();
                }
                if (slotColor === null && village.tribe) {
                    colorBox = this.tribe[ village.tribe.id ];
    
                    if (colorBox) {
                        slotColor = colorBox.get();
                    }
                }
            }
    
            if (slotColor !== null) {
                return slotColor.slot;
            }

            return null;
        }
    }

    /******************************/

    let currentPalette: Palette = null;
    const map_palette = {} as {[key: string]: Palette};

    /******************************/

    return {
        getVillageSlotColor(
            village: Village
        ) {
            const slotColor = currentPalette
                ? currentPalette.getVillageSlotColor(village)
                : null;

            // default
            if (slotColor === null) {
                if (village.character) {
                    return COLOR_INDEX_VILLAGE_PLAYER;
                } else {
                    return COLOR_INDEX_VILLAGE_BARBARIAN;
                }
            }

            return slotColor;
        },
        paletteUse(
            name: string
        ) {
            if (!(name in map_palette)) {
                map_palette[ name ] = new Palette();
            }
            if (currentPalette !== map_palette[ name ]) {
                currentPalette = map_palette[ name ];

                for (let village of context.mapData.villageInterator()) {
                    context.buffersManager.tileSetColorSlot(
                        village.x,
                        village.y,
                        context.getVillageSlotColor(village)
                    );
                }
                
                context.renderer.updateData(context.buffersManager.getDataBuffer());
                context.renderer.requestUpdate();
            }
        },
        palleteUpdate(
            palette: ItemPalette[]
        ) {
            if (currentPalette) {
                currentPalette.update(palette);
    
                context.renderer.updateColors(context.buffersManager.getColorBuffer());
                context.renderer.updateData(context.buffersManager.getDataBuffer());
                context.renderer.requestUpdate();
            }
        }
    };
}