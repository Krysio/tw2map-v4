import { Context } from "canvas";
import MapItem from "data/data/Item";
import Village from "data/data/Village";
import debug from 'debug';
import {
    COLOR_INDEX_VILLAGE_BARBARIAN,
    COLOR_INDEX_VILLAGE_PLAYER,
    COLOR_INDEX_BACKGROUND
} from "canvas/data/mapColors";

/******************************/

const debugLog = debug('app:canvas:featurePalette');

/******************************/

type ItemPalette = {
    uuid: string,
    item: MapItem,
    color: {
        uuid: string,
        index: string,
        value: string
    }
};

/******************************/

export default function featurePalette(
    refContext: any
) {
    const context = refContext as Context;

    /******************************/

    function sortColors(
        a: Color,
        b: Color
    ) {
        if (a.index === b.index) {
            return 0;
        }

        if (a.index === '0') {
            return 1;
        }
        if (b.index === '0') {
            return -1;
        }

        if (a.index > b.index) {
            return 1;
        } else {
            return -1;
        }
    }

    class Color {
        slot: number;
        active = true;

        constructor(
            public uuid: string,
            public value: string,
            public index: string
        ) {
            this.slot = context.buffersManager.addColor(value);
        }
    }

    class ColorBox {
        color1List: Color[] = [];
        color2List: Color[] = [];
        color3List: Color[] = [];

        constructor(
            public item: MapItem
        ) {}

        addColor(
            color: Color,
            colorIndex: 1 | 2 | 3
        ) {
            const index = this[`color${ colorIndex }List`].indexOf(color);

            if (index === -1) {
                this[`color${ colorIndex }List`].push(color);
            }

            this[`color${ colorIndex }List`].sort(sortColors);
        }

        get(
            colorIndex: 1 | 2 | 3
        ) {
            if (this[`color${ colorIndex }List`].length) {
                for (let i = 0; i < this[`color${ colorIndex }List`].length; i++) {
                    if (this[`color${ colorIndex }List`][ i ].active === false) {
                        this[`color${ colorIndex }List`].splice(i, 1);
                        i--;
                    }
                }
                this[`color${ colorIndex }List`].sort(sortColors);
            }

            return this[`color${ colorIndex }List`][0] || null;
        }
    }

    class Palette {
        village = {} as {[key: number]: ColorBox};
        character = {} as {[key: number]: ColorBox};
        tribe = {} as {[key: number]: ColorBox};
        map_uuid_color1 = {} as {[key: string]: Color};
        map_uuid_color2 = {} as {[key: string]: Color};
        map_uuid_color3 = {} as {[key: string]: Color};

        /******************************/

        getColor(
            uuid: string,
            colorIndex: 1 | 2 | 3
        ) {
            if (uuid in this[`map_uuid_color${colorIndex}`]) {
                return this[`map_uuid_color${colorIndex}`][ uuid ];
            }
            return null;
        }

        update(
            palette: ItemPalette[],
            colorIndex: 1 | 2 | 3
        ) {
            // disable all colors
            for (let uuid in this[`map_uuid_color${colorIndex}`]) {
                this[`map_uuid_color${colorIndex}`][ uuid ].active = false;
            }

            const dirtyVillages = [] as Village[];

            for (let itemPalette of palette) {
                const { id, mapItemType: type } = itemPalette.item;

                if (itemPalette.color === null) {
                    const villageList = itemPalette.item.getVillages();
                    for (let village of villageList) {
                        const index = dirtyVillages.indexOf(village);

                        if (index === -1) {
                            dirtyVillages.push(village);
                        }
                    }
                    continue;
                }

                let color = this.getColor(
                    itemPalette.color.uuid,
                    colorIndex
                );

                if (color === null) {
                    color = new Color(
                        itemPalette.color.uuid,
                        itemPalette.color.value,
                        itemPalette.color.index
                    );
                    this[`map_uuid_color${colorIndex}`][ itemPalette.color.uuid ] = color;
                } else {
                    color.active = true;
                    color.value = itemPalette.color.value;
                    color.index = itemPalette.color.index;
                    context.buffersManager.setColor(color.slot, color.value);
                }

                if (type in this) {
                    let colorBox: ColorBox = this[ type ][ id ];
                    if (!(itemPalette.item.id in this[ type ])) {
                        colorBox = this[ type ][ id ] = new ColorBox(itemPalette.item);
                    }
                    colorBox.addColor(color, colorIndex);

                    const villageList = itemPalette.item.getVillages();
                    for (let village of villageList) {
                        const index = dirtyVillages.indexOf(village);

                        if (index === -1) {
                            dirtyVillages.push(village);
                        }
                    }
                }
            }

            for (let village of dirtyVillages) {
                context.buffersManager[`tileSetColor${colorIndex}`](
                    village.x,
                    village.y,
                    context.buffersManager.getIntColorSlot(
                        context.getVillageSlotColor(village, colorIndex)
                    )
                );
            }
        }

        getVillageSlotColor(
            village: Village,
            colorIndex: 1 | 2 | 3 = 1
        ) {
            let colorBox: ColorBox;
            let slotColor: Color = null;

            colorBox = this.village[ village.id ];
            if (colorBox) {
                debugLog('V', colorBox);
                slotColor = colorBox.get(colorIndex);
            }

            //debugLog('V', JSON.stringify(slotColor));

            if (village.character) {
                colorBox = this.character[ village.character.id ];

                if (colorBox) {
                    const characterSlotColor = colorBox.get(colorIndex);

                    //debugLog('C', JSON.stringify(slotColor), JSON.stringify(characterSlotColor));

                    if (slotColor === null
                        || (
                            characterSlotColor !== null
                            && characterSlotColor.index !== '0'
                            && slotColor.index > characterSlotColor.index
                        )
                    ) {
                        slotColor = characterSlotColor;
                    }
                }
            }

            if (village.tribe) {
                colorBox = this.tribe[ village.tribe.id ];

                if (colorBox) {
                    const tribeSlotColor = colorBox.get(colorIndex);

                    //debugLog('T', JSON.stringify(slotColor), JSON.stringify(tribeSlotColor));

                    if (slotColor === null
                        || (
                            tribeSlotColor !== null
                            && tribeSlotColor.index !== '0'
                            && slotColor.index > tribeSlotColor.index
                        )
                    ) {
                        slotColor = tribeSlotColor;
                    }
                }
            }

            if (slotColor !== null) {
                return slotColor.slot;
            }

            return null;
        }
    }

    /******************************/

    let currentPalette: Palette = null;
    const map_palette = {} as {[key: string]: Palette};

    if (debugLog.enabled) {
        window['dev'] = window['dev'] || {};
        window['dev'].getCurrentPalette = () => currentPalette;
    }

    /******************************/

    return {
        getVillageSlotColor(
            village: Village,
            colorIndex: 1 | 2 | 3 = 2
        ) {
            let slotColor;

            if (colorIndex === 3) {
                slotColor = currentPalette
                    ? currentPalette.getVillageSlotColor(
                        village,
                        3
                    )
                    : null;

                if (slotColor !== null) {
                    return slotColor;
                }

                colorIndex = 2;
            }

            slotColor = currentPalette
                ? currentPalette.getVillageSlotColor(
                    village,
                    colorIndex
                )
                : null;

            // default
            switch (colorIndex) {
                case 1: {
                    if (slotColor === null) {
                        return COLOR_INDEX_BACKGROUND
                    }
                } break;
                case 2: {
                    if (slotColor === null) {
                        if (village.character) {
                            return COLOR_INDEX_VILLAGE_PLAYER;
                        } else {
                            return COLOR_INDEX_VILLAGE_BARBARIAN;
                        }
                    }
                } break;
            }

            return slotColor;
        },
        paletteUse(
            name: string
        ) {
            if (!(name in map_palette)) {
                map_palette[ name ] = new Palette();
            }
            if (currentPalette !== map_palette[ name ]) {
                currentPalette = map_palette[ name ];

                for (let village of context.mapData.villageInterator()) {
                    for (let i of [1,2,3]) {
                        context.buffersManager.tileSetColor2(
                            village.x,
                            village.y,
                            context.buffersManager.getIntColorSlot(
                                context.getVillageSlotColor(village, i as 1 | 2 | 3)
                            )
                        );
                    }
                }

                context.renderer.updateData(context.buffersManager.getDataBuffer());
                context.renderer.requestUpdate();
            }
        },
        palleteUpdate(
            palette: {
                color1: ItemPalette[],
                color2: ItemPalette[],
                color3: ItemPalette[]
            }
        ) {
            if (currentPalette) {
                for (let i = 1; i <= 3; i++) {
                    currentPalette.update(palette[`color${i}`], i as 1 | 2 | 3);
                }
                context.renderer.updateColors(context.buffersManager.getColorBuffer());
                context.renderer.updateData(context.buffersManager.getDataBuffer());
                context.renderer.requestUpdate();
            }
        }
    };
}