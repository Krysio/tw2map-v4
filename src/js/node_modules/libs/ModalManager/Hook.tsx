import * as React from 'react';
import uuid from 'uuid/v4';
import ModalManager, { Modal } from './';
import { emptyComponent } from './helper';

import {
    Position, Size,
    HookOptions,
    Orientation, Mode
} from './types';

/******************************/

export default class Hook {
    uuid: string = uuid();
    layout: JSX.Element;

    state: {
        hidden: boolean,
        position: Position
        previousPosition: Position,
        startMovePosition: Position
        size: Size,
        orientation: Orientation,
        updateStyleHasBeenRequest: boolean
    } = {
        hidden: false,
        position: {x: 0, y: 0},
        previousPosition: {x: 0, y: 0},
        startMovePosition: {x: 0, y: 0},
        size: {w: 0, h: 0},
        orientation: Orientation.TL,
        updateStyleHasBeenRequest: false
    };
    options: HookOptions = {
        alwaysMounted: false,
        mode: Mode.Default,
        hideWhenInactive: false,
        autoPosition: false,
        autoMount: true,
        background: false,
        position: {x: 0, y: 0},
        hidden: false
    };

    // component

    viewComponent: {
        rootElement: HTMLElement,
        containerElement: HTMLElement,
        updateView: () => void,
        updateViewHasBeenRequest: boolean
    } = {
        rootElement: null,
        containerElement: null,
        updateView: null,
        updateViewHasBeenRequest: false
    };
    dirtyView: boolean = false;

    /******************************/

    constructor(
        public modalManager: ModalManager = null
    ) {
        this.updateStyle = this.updateStyle.bind(this);

        this.state.hidden = this.options.hidden;
        this.options.position = this.options.position || {x: 0, y: 0};
        this.setPosition(
            this.options.position.x,
            this.options.position.y
        );

        // auto mount

        if (this.options.autoMount === true) {
            this.mount();
        }

        this.close = this.close.bind(this);
        this.hide = this.hide.bind(this);
        this.show = this.show.bind(this);
        this.active = this.active.bind(this);
        this.setPosition = this.setPosition.bind(this);
        this.calcTooltip = this.calcTooltip.bind(this);
        this.moveStart = this.moveStart.bind(this);
        this.moveTo = this.moveTo.bind(this);
        this.moveEnd = this.moveEnd.bind(this);
    }

    /******************************/

    /**
     * API for a View
     * @param component ModalComponent
     */
    public bindComponent(
        component: Modal
    ): void {
        let vC = this.viewComponent;

        if (component) {
            vC.rootElement = component.getRootElement();
            vC.containerElement = component.getContainerElement();
            vC.updateView = () => component.setState({time: Date.now()});

            let size = this.state.size;

            size.w = vC.containerElement.offsetWidth;
            size.h = vC.containerElement.offsetHeight;
        } else {
            vC.rootElement = null;
            vC.containerElement = null;
            vC.updateView = null;
        }
    }

    /**
     * API for a View - Callback after render
     */
    public viewComponentHasBeenRendered(): void {
        let vC = this.viewComponent;

        vC.updateViewHasBeenRequest = false;

        if (!this.isHidden()) {
            let size = this.state.size;

            size.w = vC.containerElement.offsetWidth;
            size.h = vC.containerElement.offsetHeight;
        }
    }

    /**
     * For self & the Manager
     */
    protected requestUpdateView(): void {
        if (this.dirtyView === true
            && this.viewComponent.updateViewHasBeenRequest === false
            && this.viewComponent.updateView !== null
        ) {
            this.viewComponent.updateViewHasBeenRequest = true;
            this.viewComponent.updateView();
        }
    }

    /******************************/

    moveStart(x, y): void {
        this.state.startMovePosition.x = x;
        this.state.startMovePosition.y = y;

        if (this.modalManager) {
            this.modalManager.moveObject(this);
        }
    }

    moveTo(x, y): void {
        let position = this.state.position;
        let startMove = this.state.startMovePosition;
        let previousPosition = this.state.previousPosition;

        position.x = x = x + (previousPosition.x - startMove.x);
        position.y = y = y + (previousPosition.y - startMove.y);

        this.requestUpdateStyle();
    }

    moveEnd(): void {
        let previousPosition = this.state.previousPosition;
        let { x, y } = this.state.position;

        // przypisanie do poprzedniej pozycji

        previousPosition.x = x;
        previousPosition.y = y;

        // poprawa pozycji - poza obszarem
        this.fixPosition();
    }

    /******************************/

    close(): void {
        if (this.options.alwaysMounted) {
            this.hide();
        } else {
            this.unmount();
        }
    }

    hide(): void {
        if (this.state.hidden === false) {
            this.state.hidden = true;

            this.dirtyView = true;
            this.requestUpdateView();
        }
    }

    show(): void {
        if (this.state.hidden === true) {
            this.state.hidden = false;

            this.dirtyView = true;

            if (this.options.alwaysMounted) {
                this.active();
            }

            this.requestUpdateView();
        }
    }

    isHidden(): boolean {
        return this.state.hidden;
    }

    /******************************/

    active(): void {
        if (this.modalManager) {
            this.modalManager.activeHook(this);
        }
    }

    canBeActive(): boolean {
        if (this.options.mode === Mode.Tooltip) {
            return false;
        }

        return true;
    }

    willHaveInactived(): void {
        if (this.options.hideWhenInactive === true) {
            this.hide();
        }
    }

    /******************************/

    setPosition(
        x: number,
        y: number
    ): void {
        let position: Position = this.state.position,
            previousPosition: Position = this.state.previousPosition;

        previousPosition.x = x;
        previousPosition.y = y;
        position.x = x;
        position.y = y;

        this.requestUpdateStyle();
    }

    setCursorPosition(): void {
        let cursorPosition: Position = this.modalManager.getCursorPosition(),
            size: Size = this.modalManager.getSize(),
            position: Position = { ...cursorPosition };

        if (cursorPosition.x < size.w / 2) {
            position.x+= 10;
        } else {
            position.x-= 10;
        }

        if (cursorPosition.y < size.h / 2) {
            position.y+= 10;
        } else {
            position.y-= 10;
        }

        this.setPosition(position.x, position.y);
        this.calcOrientation();
    }

    requestUpdateStyle(): void {
        if (!this.state.updateStyleHasBeenRequest) {
            requestAnimationFrame(this.updateStyle);
        }
    }

    protected updateStyle(): void {
        this.state.updateStyleHasBeenRequest = false;

        let { x, y }: Position = this.state.position;
        let rE: HTMLElement = this.viewComponent.rootElement;

        if (rE) {
            rE.style.transform = `translate(${ x }px, ${ y }px)`;
        }
    }

    fixPosition(): void {
        let mM = this.modalManager;

        if (mM !== null) {
            let { x, y }: Position = this.state.position;
            let { w: thisWidth, h: thisHeight } = this.state.size;
            let { w: areaWidth, h: areaHeight }: Size = mM.getSize();
            let o = this.state.orientation;
            let changed: boolean = false,
                temp: number;

            temp = o & 1 ? thisWidth : 0;
            if (x < temp) {
                x = temp;
                changed = true;
            }

            temp = o & 2 ? thisHeight : 0;
            if (y < temp) {
                y = temp;
                changed = true;
            }

            temp = o & 1 ? areaWidth : areaWidth - thisWidth;
            if (x > temp) {
                x = temp;
                changed = true;
            }

            temp = o & 2 ? areaHeight : areaHeight - thisHeight;
            if (y > temp) {
                y = temp;
                changed = true;
            }

            if (changed) {
                this.setPosition(x, y);
            }
        }
    }

    /**
     * wyliczenie orientacji
     */
    calcOrientation(): void {
        let { w, h }: Size = this.modalManager.getSize(),
            { x, y }: Position = this.modalManager.getCursorPosition();

        this.state.orientation = 0; // TL
        if (x / w > 0.5) {
            this.state.orientation|= 1; // set R
        }
        if (y / h > 0.5) {
            this.state.orientation|= 2; // set B
        }
    }

    calcTooltip(): void {
        this.calcOrientation();

        let o: Orientation = this.state.orientation,
            { x, y }: Position = this.modalManager.getCursorPosition();

        this.setPosition(x + (o&1?-1:1)*10, y + (o&2?-1:1)*10);
    }

    /******************************/

    mount(): void {
        if (this.modalManager !== null) {
            this.modalManager.mounHook(this);

            // tooltipMode

            if (this.options.mode === Mode.Tooltip) {
                this.modalManager.on('move', this.calcTooltip);
            }

            // start position
            if (this.options.autoPosition === true) {
                let { x, y }: Position = this.modalManager.state.move.current;

                this.setPosition(x, y);
            }
        }
    }

    unmount(): void {
        if (this.modalManager) {
            this.modalManager.unmountHook(this.uuid);

            // tooltipMode

            if (this.options.mode === Mode.Tooltip) {
                this.modalManager.removeListener('move', this.calcTooltip);
            }
        }
    }

    /******************************/

    /**
     * API for a coffe to code converter
     */
    setLayout(
        layout: JSX.Element
    ): void {
        // zczytywanie konfiguracji
        this.state.hidden = layout.props.hidden || false;
        this.options.alwaysMounted = layout.props.hideNotUnmount || false;
        this.options.autoMount = !(layout.props.hidden || false);

        // layout in new component with key
        this.layout = React.createElement(
            emptyComponent,
            { key: this.uuid }, // props
            React.createElement(
                layout.type,
                {
                    ...layout.props,
                    hook: this
                }
            )
        );
    }

    /**
     * API for a Manager
     */
    getTemplate(): JSX.Element {
        return this.layout;
    }
}
