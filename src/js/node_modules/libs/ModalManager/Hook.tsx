import * as React from 'react';
import uuid from 'uuid/v4';
import ModalManager, { Modal } from './';
import { emptyComponent } from './helper';

import {
    Position, Size,
    HookOptions,
    Orientation, Mode
} from './types';

/******************************/

export default class Hook {
    uuid: string = uuid();
    layout: JSX.Element;

    state: {
        hidden: boolean,
        position: Position
        previousPosition: Position,
        startMovePosition: Position,
        size: Size,
        orientation: Orientation
    } = {
        hidden: false,
        position: {x: 0, y: 0},
        previousPosition: {x: 0, y: 0},
        startMovePosition: {x: 0, y: 0},
        size: {w: 0, h: 0},
        orientation: Orientation.TL
    };
    options: HookOptions = {
        alwaysMounted: false,
        mode: Mode.Default,
        hideWhenInactive: false,
        autoPosition: false,
        autoMount: true,
        background: false,
        position: {x: 0, y: 0},
        hidden: false
    };

    // component

    viewComponent: {
        rootElement: HTMLElement,
        containerElement: HTMLElement,
        updateView: () => void,
        updateViewHasBeenRequest: boolean
    } = {
        rootElement: null,
        containerElement: null,
        updateView: null,
        updateViewHasBeenRequest: false
    };
    dirtyView: boolean = false;

    /******************************/

    constructor(
        public modalManager: ModalManager = null
    ) {
        this.state.hidden = this.options.hidden;
        this.options.position = this.options.position || {x: 0, y: 0};
        this.setPosition(
            this.options.position.x,
            this.options.position.y
        );

        // auto mount

        if (this.options.autoMount === true) {
            this.mount();
        }

        this.close = this.close.bind(this);
        this.hide = this.hide.bind(this);
        this.show = this.show.bind(this);
        this.active = this.active.bind(this);
        this.setPosition = this.setPosition.bind(this);
        this.calcTooltip = this.calcTooltip.bind(this);
        this.moveStart = this.moveStart.bind(this);
        this.moveTo = this.moveTo.bind(this);
        this.moveEnd = this.moveEnd.bind(this);
    }

    /******************************/

    /**
     * API for a View
     * @param component ModalComponent
     */
    public bindComponent(
        component: Modal
    ): void {
        if (component) {
            this.viewComponent.rootElement = component.getRootElement();
            this.viewComponent.containerElement = component.getContainerElement();
            this.viewComponent.updateView = () => component.setState({time: Date.now()});
        } else {
            this.viewComponent.rootElement = null;
            this.viewComponent.containerElement = null;
            this.viewComponent.updateView = null;
        }
    }

    /**
     * API for a View - Callback after render
     */
    public viewComponentHasBeenRendered(): void {
        this.viewComponent.updateViewHasBeenRequest = false;
    }

    /**
     * For self & the Manager
     */
    protected requestUpdateView(): void {
        if (this.dirtyView === true
            && this.viewComponent.updateViewHasBeenRequest === false
            && this.viewComponent.updateView !== null
        ) {
            this.viewComponent.updateViewHasBeenRequest = true;
            this.viewComponent.updateView();
        }
    }

    /******************************/

    moveStart(x, y): void {
        this.state.startMovePosition.x = x;
        this.state.startMovePosition.y = y;

        if (this.modalManager) {
            this.modalManager.moveObject(this);
        }
    }

    moveTo(x, y): void {
        let position = this.state.position;
        let startMove = this.state.startMovePosition;
        let previousPosition = this.state.previousPosition;

        position.x = x + (previousPosition.x - startMove.x);
        position.y = y + (previousPosition.y - startMove.y);

        let rE = this.viewComponent.rootElement;

        if (rE) {
            rE.style.transform = `translate(${ position.x }px, ${ position.y }px)`;
        }
    }

    moveEnd(): void {
        let previousPosition = this.state.previousPosition;
        let { x, y } = this.state.position;

        // przypisanie do poprzedniej pozycji

        previousPosition.x = x;
        previousPosition.y = y;

        // poprawa pozycji - poza obszarem
        this.fixPosition();
    }

    /******************************/

    close(): void {
        if (this.options.alwaysMounted) {
            this.hide();
        } else {
            this.unmount();
        }
    }

    hide(): void {
        if (this.state.hidden === false) {
            this.state.hidden = true;

            this.dirtyView = true;
            this.requestUpdateView();
        }
    }

    show(): void {
        if (this.state.hidden === true) {
            this.state.hidden = false;

            this.dirtyView = true;
            this.requestUpdateView();
        }
    }

    /******************************/

    active(): void {
        if (this.modalManager) {
            this.modalManager.activeHook(this);
        }
    }

    canBeActive(): boolean {
        if (this.options.mode === Mode.Tooltip) {
            return false;
        }

        return true;
    }

    willHaveInactived(): void {
        if (this.options.hideWhenInactive === true) {
            this.hide();
        }
    }

    /******************************/

    setPosition(
        x: number,
        y: number
    ): void {
        let position: Position = this.state.position,
            previousPosition: Position = this.state.previousPosition;

        previousPosition.x = x;
        previousPosition.y = y;
        position.x = x;
        position.y = y;

        let rE = this.viewComponent.rootElement;

        if (rE) {
            rE.style.transform = `translate(${ x }px, ${ y }px)`;
        }
    }

    fixPosition(): void {
        let mM = this.modalManager,
            cE = this.viewComponent.containerElement;

        if (mM !== null
            && cE !== null
        ) {
            let { x, y }: Position = this.state.position;
            let { clientWidth: thisWidth, clientHeight: thisHeight } = cE;
            let { w: areaWidth, h: areaHeight }: Size = mM.getSize();
            let changed: boolean = false;

            if (x < 0) {
                x = 0;
                changed = true;
            }

            if (y < 0) {
                y = 0;
                changed = true;
            }

            let maxX: number = areaWidth - thisWidth;
            if (x > maxX) {
                x = maxX;
                changed = true;
            }

            let maxY: number = areaHeight - thisHeight;
            if (y > maxY) {
                y = maxY;
                changed = true;
            }

            if (changed) {
                this.setPosition(x, y);
            }
        }
    }

    /**
     * wyliczenie orientacji
     */
    calcOrientation(): void {
        let { w, h }: Size = this.modalManager.state.size,
            { x, y }: Position = this.modalManager.state.move.current;

        this.state.orientation = 0; // TL
        if (x / w > 0.5) {
            this.state.orientation|= 1; // set R
        }
        if (y / h > 0.5) {
            this.state.orientation|= 2; // set B
        }
    }

    calcTooltip(): void {
        this.calcOrientation();

        let o: Orientation = this.state.orientation,
            { x, y }: Position = this.modalManager.state.move.current;

        this.setPosition(x + (o&1?-1:1)*10, y + (o&2?-1:1)*10);
    }

    /******************************/

    mount(): void {
        if (this.modalManager !== null) {
            this.modalManager.mounHook(this);

            // tooltipMode

            if (this.options.mode === Mode.Tooltip) {
                this.modalManager.on('move', this.calcTooltip);
            }

            // start position
            if (this.options.autoPosition === true) {
                let { x, y }: Position = this.modalManager.state.move.current;

                this.setPosition(x, y);
            }
        }
    }

    unmount(): void {
        if (this.modalManager) {
            this.modalManager.unmountHook(this.uuid);

            // tooltipMode

            if (this.options.mode === Mode.Tooltip) {
                this.modalManager.removeListener('move', this.calcTooltip);
            }
        }
    }

    /******************************/

    /**
     * API for a coffe to code converter
     */
    setLayout(
        layout: JSX.Element
    ): void {
        // zczytywanie konfiguracji
        this.state.hidden = layout.props.hidden || false;

        // layout in new component with key
        this.layout = React.createElement(
            emptyComponent,
            { key: this.uuid }, // props
            React.createElement(
                layout.type,
                {
                    ...layout.props,
                    hook: this
                }
            )
        );
    }

    /**
     * API for a Manager
     */
    getTemplate(): JSX.Element {
        return this.layout;
    }
}
