import * as React from 'react';

import uuid from 'uuid/v4';
import ModalsContainer from './ModalsContainer';
import Hook from './Hook';
import {
    Position, Size
} from './types';
import { EventEmitter } from 'events';

/******************************/

export default class ModalManager extends EventEmitter {
    uuid: string = uuid();
    hookList: Hook[] = [];
    hookOrder: Hook[] = []; // mousedown -> replace DOM -> not click event :/
    hookSpyCursor: Hook[] = [];
    currentActiveHook: Hook = null;
    hookMap: {[key: string]: Hook} = {};

    // state

    state: {
        position: Position,
        size: Size,
        move: {
            click: boolean,
            move: boolean,
            start: Position,
            current: Position,
            end: Position,
            hook: Hook | null,
            time: number
        }
    } = {
        position: {x: 0, y: 0},
        size: {w: 0, h: 0},
        move: {
            click: false,
            move: false,
            start: {x: 0, y: 0},
            current: {x: 0, y: 0},
            end: {x: 0, y: 0},
            hook: null,
            time: 0
        }
    };

    // component

    viewComponent: {
        rootElement: HTMLElement,
        updateView: () => void,
        updateViewHasBeenRequest: boolean
    } = {
        rootElement: null,
        updateView: null,
        updateViewHasBeenRequest: false
    };
    dirtyView: boolean = false;

    /******************************/

    constructor() {
        super();

        this.Container = this.Container.bind(this);

        // TODO debug
        window['mm'] = this;
    }

    /******************************/

    /**
     * API for a coffe to code converter
     */
    public Container(
        props: {}
    ): JSX.Element {
        return (
            <ModalsContainer manager={ this } key={ this.uuid } />
        );
    }

    /**
     * API for a View
     * @param component ModalComponent
     */
    public bindComponent(
        component: ModalsContainer
    ): void {
        if (component) {
            this.viewComponent.rootElement = component.getRootElement();
            this.viewComponent.updateView = () => component.setState({time: Date.now()});
            this.initEventListeners();
            this.onResize(null);
        } else {
            this.cleanEventListeners();
            this.viewComponent.rootElement = null;
            this.viewComponent.updateView = null;
        }
    }

    protected initEventListeners(): void {
        window.addEventListener('resize', this.onResize, false);
        window.addEventListener('mousemove', this.onMouseMove, true);
        window.addEventListener('touchmove', this.onMouseMove, {capture: true, passive: false});
        document.body.addEventListener('mouseenter', this.onMouseEnter, true);
        document.body.addEventListener('mouseleave', this.onMouseUp, false);

        let rE = this.viewComponent.rootElement;

        rE.addEventListener('mousedown', this.onMouseDown, false);
        window.addEventListener('touchstart', this.onMouseDown, {capture: true, passive: false});
        rE.addEventListener('mouseup', this.onMouseUp, false);
        window.addEventListener('touchend', this.onMouseUp, {capture: true, passive: false});
        window.addEventListener('touchancel', this.onMouseUp, {capture: true, passive: false});
    }

    protected cleanEventListeners(): void {
        window.removeEventListener('resize', this.onResize);
        window.removeEventListener('mousemove', this.onMouseMove);
        window.removeEventListener('touchmove', this.onMouseMove);
        document.body.addEventListener('mouseenter', this.onMouseEnter);
        document.body.addEventListener('mouseleave', this.onMouseUp);

        let rE = this.viewComponent.rootElement;

        rE.removeEventListener('mousedown', this.onMouseDown);
        window.removeEventListener('touchstart', this.onMouseDown);
        rE.removeEventListener('mouseup', this.onMouseUp);
        window.removeEventListener('touchend', this.onMouseUp);
        window.removeEventListener('touchancel', this.onMouseUp);
    }

    /**
     * API for a View - Callback after render
     */
    public viewComponentHasBeenRendered(): void {
        this.viewComponent.updateViewHasBeenRequest = false;
    }

    /**
     * For self
     */
    protected requestUpdateView(): void {
        if (this.dirtyView === true
            && this.viewComponent.updateViewHasBeenRequest === false
            && this.viewComponent.updateView !== null
        ) {
            this.viewComponent.updateViewHasBeenRequest = true;
            this.viewComponent.updateView();
        }
    }

    /******************************/

    /**
     * For self
     */
    protected onResize = (
        e: UIEvent
    ): void => {
        if (this.viewComponent.rootElement === null) return;

        let rootElement = this.viewComponent.rootElement,
            { left, top } = rootElement.getBoundingClientRect();

        this.state.size.w = rootElement.offsetWidth;
        this.state.size.h = rootElement.offsetHeight;
        this.state.position.x = left;
        this.state.position.y = top;

        this.dirtyView = true;
        this.requestUpdateView();

        for (let hook of this.hookList) {
            hook.fixPosition();
        }
    }

    protected onMouseDownTouchCaptured = false;
    protected onMouseDown = (
        e: MouseEvent | TouchEvent
    ): void => {
        let move = this.state.move,
            start = move.start;

        if (e instanceof TouchEvent) {
            this.onMouseDownTouchCaptured = true;

            start.x = e.touches[0].clientX;
            start.y = e.touches[0].clientY;

            let position = this.state.position;

            move.current.x = start.x - position.x;
            move.current.y = start.y - position.y;
        } else if (this.onMouseDownTouchCaptured === false) {
            start.x = e.clientX;
            start.y = e.clientY;
        } else {
            this.onMouseDownTouchCaptured = false;
        }

        this.state.move.move = false;
        this.state.move.click = true;
    }

    protected onMouseUpTouchCaptured = false;
    protected onMouseUp = (
        e: MouseEvent | TouchEvent
    ): void => {
        let move = this.state.move;

        if (e instanceof TouchEvent) {
            this.onMouseUpTouchCaptured = true;

            if (move.move) {
                move.end.x = move.current.x;
                move.end.y = move.current.y;
            } else {
                move.end.x = move.start.x;
                move.end.y = move.start.y;
            }
        } else if (this.onMouseUpTouchCaptured === false) {
            move.end.x = e.clientX;
            move.end.y = e.clientY;
        } else {
            this.onMouseUpTouchCaptured = false;
        }

        move.click = false;
        move.move = false;

        if (move.hook !== null) {
            const hook = move.hook;

            move.hook = null;
            hook.moveEnd();
        }
    }

    protected onMouseMove = (
        e: MouseEvent | TouchEvent
    ): void => {
        let move = this.state.move,
            now = Date.now()

        if (move.move
            && move.hook !== null
        ) {
            e.stopPropagation();
        }

        if (now - move.time < 7) {
            return;
        } else {
            move.time = now;
        }

        let position = this.state.position,
            clientX, clientY;

        if (e instanceof TouchEvent) {
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else {
            clientX = e.clientX;
            clientY = e.clientY;
        }

        let x = clientX - position.x,
            y = clientY - position.y;

        move.current.x = x;
        move.current.y = y;

        if (move.click
            && !move.move
        ) {
            let diffX = x - move.start.x;
            let diffY = y - move.start.y;

            // prÃ³g 5 px
            if (diffX > 5
                || diffX < -5
                || diffY > 5
                || diffY < -5
            ) {
                move.move = true;
            }
        }

        if (move.move) {
            if (move.hook !== null) {
                move.hook.moveTo(x, y);
                e.stopPropagation();
            }
        } else {
            for (let i = 0; i < this.hookSpyCursor.length; i++) {
                this.hookSpyCursor[ i ].setCursorPosition();
            }
        }
    }

    onMouseEnter = (
        e: MouseEvent
    ): void => {
        let move = this.state.move;

        if (move.move
            && move.hook !== null
        ) {
            e.stopPropagation();
        }
    }

    /******************************/

    moveObject(hook): void {
        if (this.state.move.hook !== hook) {
            this.state.move.hook = hook;

            this.dirtyView = true;
        }
    }

    mounHook(
        hook: Hook
    ): void {
        if (!this.hookMap[ hook.uuid ]) {
            this.hookMap[ hook.uuid ] = hook;
            this.hookList.push(hook);
            this.hookOrder.push(hook);
            this.activeHook(hook);

            this.dirtyView = true;
            this.requestUpdateView();
        }
    }

    spyCursor(
        hook: Hook
    ): void {
        if (this.hookMap[ hook.uuid ]) {
            this.hookSpyCursor.push(hook);
        }
    }

    getHook(
        uuid: string
    ): Hook | null {
        if (this.hookMap[ uuid ]) {
            return this.hookMap[ uuid ];
        }

        return null;
    }

    unmountHook(
        uuid: string
    ): void {
        let hook = this.hookMap[ uuid ];

        if (hook) {
            if (this.currentActiveHook === hook) {
                this.currentActiveHook = null;
            }

            this.hookList.splice(
                this.hookList.indexOf(hook),
                1
            );
            this.hookOrder.splice(
                this.hookOrder.indexOf(hook),
                1
            );
            this.hookSpyCursor.splice(
                this.hookSpyCursor.indexOf(hook),
                1
            );
            delete this.hookMap[ uuid ];

            // active next hook
            for (let hook of this.hookOrder) {
                if (hook.canBeActive()
                    && !hook.isHidden()
                ) {
                    this.activeHook(hook);
                    break;
                }
            }

            this.dirtyView = true;
            this.requestUpdateView();
        }
    }

    activeHook(
        hook: Hook
    ): void {
        if (hook.canBeActive()) {
            // poinformowanie o zmianie na nieaktywny
            for (let hookFromList of this.hookList) {
                if (hook !== hookFromList) {
                    hookFromList.willHaveInactived();
                }
            }

            this.currentActiveHook = hook;
        }

        // przenoszenie hook'a na szczyt listy

        let hookIndex: number = this.hookOrder.indexOf(hook);

        if (hookIndex !== -1
            && hookIndex !== this.hookOrder.length - 1
        ) {
            // wymiana aktywnego hook'a
            this.hookOrder.splice(hookIndex, 1);
            this.hookOrder.push(hook);
        }

        this.dirtyView = true;
        this.requestUpdateView();
    }

    closeAll() {
        for (let hook of this.hookList) {
            hook.close();
        }

        this.dirtyView = true;
        this.requestUpdateView();
    }

    /******************************/

    isMoveing(): boolean {
        return this.state.move.move;
    }

    /**
     * API for a coffe to code converter
     */
    createHook(): Hook {
        let hook = new Hook(this);

        return hook;
    }

    getSize(): Size {
        return this.state.size;
    }

    getCursorPosition(): Position {
        return this.state.move.current;
    }
}

