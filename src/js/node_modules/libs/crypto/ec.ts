import { ec as EC, eddsa as EDDSA } from 'elliptic';
import { createHash } from 'crypto';

/******************************/

const ec = new EC('secp256k1');

export type HexPrivateKey = string;
export type HexPublicKey = string;
export type HexSignature = string;
export function sha256(
    input: string,
    encoding: 'hex' | 'base64' = 'hex'
): string {
    let hash = createHash('sha256').update(input, 'utf8');

    return hash.digest(encoding);
}

/******************************/

/**
 * Generuje parę kluczy eliptycznych w formacie base64
 * @return [HexPrivateKey, HexPublicKey]
 */
export function getKeys(): [HexPrivateKey, HexPublicKey] {
    let key = ec.genKeyPair(),
        hexPrivateKey = key.getPrivate('hex'),
        hexPublicKey = key.getPublic(true, 'hex'); // true - compressed

    return [
        hexPrivateKey,
        hexPublicKey
    ];
}

export function compressPublicKey(publicKey: HexPublicKey): HexPublicKey {
    let { pub } = ec.keyFromPublic(publicKey, 'hex');

    return pub.encode('hex', true);
}

export function decompressPublicKey(publicKey: HexPublicKey): HexPublicKey {
    let { pub } = ec.keyFromPublic(publicKey, 'hex');

    return pub.encode('hex', false);
}

/**
 * Podpisusywanie ciągu znaków, skrót w sha256
 * @param inputPrivateKey Klucz prywatny eliptyczny
 * @param inputText Ciąg znaków do podpisania
 */
export function sign(
    inputPrivateKey: HexPrivateKey,
    inputText: string
): string {
    let key = ec.keyFromPrivate(inputPrivateKey, 'hex'),
        hash = sha256(inputText);

    let signature: string = key.sign(hash, 'hex').toDER();

    return new Buffer(signature).toString('hex');
}

/**
 * Weryfikacja podpisu cyfrowego
 * @param inputPublicKey Klucz publiczny eliptyczny
 * @param inputText Ciąg znaków do porównania
 * @param inputSignature Podpis cyfrowy
 */
export function verify(
    inputPublicKey: HexPublicKey,
    inputText: string,
    inputSignature: HexSignature
): boolean {
    let key = ec.keyFromPublic(inputPublicKey, 'hex'),
        hash = sha256(inputText);

    return key.verify(hash, inputSignature);
}
