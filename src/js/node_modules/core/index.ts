import Renderer from 'core/Renderer';
import BuffersManager from 'core/BuffersManager';
import { dataLoader_v1, bitDataLoader_v1 } from 'core/data/loader';
import MapData from 'core/data/MapData';
import State from 'core/State';
import { initMouseEvents, initResize } from 'core/initDomEvents';
import Events from 'core/Events';
import Item from 'core/data/objects/Item';
import Village from 'core/data/objects/Village';
import Character from 'core/data/objects/Character';
import Tribe from 'core/data/objects/Tribe';
import {
    COLOR_INDEX_HOVER_ITEM,
    COLOR_INDEX_VILLAGE_PLAYER,
    COLOR_INDEX_VILLAGE_BARBARIAN,
    COLOR_INDEX_HOVER_GROUP
} from 'data/mapColors';

/******************************/

export type Api = {
    canvas: HTMLCanvasElement,
    state: State,
    buffersManager: BuffersManager,
    renderer: Renderer,
    events: Events,
    mapData: MapData,
    initPromise: Promise<void>,
    loadMapData: (url: string) => Promise<void>,
    helpers: {
        setColor: (index: number, color: string) => void
    }
}

/******************************/

export default function initMap(
    canvas: HTMLCanvasElement
): Api {
    let events = new Events();
    let buffersManager = new BuffersManager();
    let mapData = new MapData();
    let renderer = new Renderer(canvas);
    let state = new State();
    let initPromise = (async function(){
        buffersManager.init();
        await renderer.init(
            buffersManager.getDataBuffer(),
            buffersManager.getColorBuffer()
        );

        initMouseEvents(canvas, renderer, state, events);
        initResize(canvas, renderer, state);

        await bitDataLoader_v1(
            'data/mapv2-rc1.bin',
            buffersManager
        );
        renderer.updateData(buffersManager.getDataBuffer());

        // handling events
        (function(){
            let startPosition = [0, 0],
                endPosition = [0, 0],
                startTime = 0,
                endTime = 0;

            events.on('map/goTo', ({ x, y }: {x: number, y: number}) => {
                startPosition = state.getPosition();
                endPosition = [x / 1e3, y / 1e3];

                startTime = Date.now();
                endTime = startTime + 5e2;

                requestAnimationFrame(animatePosition);
            });

            function animatePosition(): void {
                let now = Date.now(),
                    progress: number;

                if (now < endTime) {
                    requestAnimationFrame(animatePosition);
                    progress = 1 - (endTime - now) / (endTime - startTime);
                    progress = 1 - 1 / (1 + Math.pow(Math.E, ((progress - 0.5)*12)));
                } else {
                    progress = 1;
                }

                state.setPosition(
                    startPosition[0] + (endPosition[0] - startPosition[0]) * progress,
                    startPosition[1] + (endPosition[1] - startPosition[1]) * progress
                );
                renderer.setPosition(
                    ...state.getPosition()
                );
            }
        })();
        (function(){
            events.on('hover/map', ({ x, y }: {x: number, y: number}) => {
                let village: Village = mapData.getVillageByCoords(x, y);

                events.emit('hover/item', village);
            });
        })();
        (function(){
            let hoveredItem: Item = null,
                hoveredGroup: Item = null;

            // hover item on map
            events.on('hover/item', (item: Item) => {
                let group: Item = null,
                    flagUpdateBuffer = false;

                if (item instanceof Village) {
                    group = item.character;
                } else if (item instanceof Character) {
                    group = item.tribe;
                }

                // remove prev group hover
                if ((
                        hoveredGroup !== group
                        && hoveredGroup !== null
                        && group !== null
                    ) || (
                        group === null
                        && hoveredGroup !== null
                    )
                ) {
                    let villageList = hoveredGroup.getVillages();

                    for (let village of villageList) {
                        buffersManager.tileSetColorSlot(
                            village.x,
                            village.y,
                            COLOR_INDEX_VILLAGE_PLAYER // TODO self color
                        );
                    }

                    flagUpdateBuffer = true;
                }

                // set group hover
                if (group !== hoveredGroup
                    && group !== null
                ) {
                    let villageList = group.getVillages();

                    for (let village of villageList) {
                        buffersManager.tileSetColorSlot(
                            village.x,
                            village.y,
                            COLOR_INDEX_HOVER_GROUP
                        );
                    }

                    flagUpdateBuffer = true;
                }

                // prev hover to group hover
                if (group !== null
                    && hoveredGroup === group
                    && hoveredItem !== item
                ) {
                    let villageList = hoveredItem.getVillages();

                    for (let village of villageList) {
                        buffersManager.tileSetColorSlot(
                            village.x,
                            village.y,
                            COLOR_INDEX_HOVER_GROUP
                        );
                    }

                    flagUpdateBuffer = true;
                }

                // remove prev item hover
                if (hoveredItem !== null
                    && hoveredItem !== item
                    && (
                        hoveredGroup !== group
                        || (
                            hoveredGroup === null
                            && group === null
                        )
                    )
                ) {
                    let villageList = hoveredItem.getVillages();

                    for (let village of villageList) {
                        buffersManager.tileSetColorSlot(
                            village.x,
                            village.y,
                            hoveredGroup
                                ? COLOR_INDEX_VILLAGE_PLAYER
                                : COLOR_INDEX_VILLAGE_BARBARIAN // TODO self color
                        );
                    }

                    flagUpdateBuffer = true;
                }

                // set item hover
                if (item !== null) {
                    let villageList = item.getVillages();

                    for (let village of villageList) {
                        buffersManager.tileSetColorSlot(
                            village.x,
                            village.y,
                            COLOR_INDEX_HOVER_ITEM
                        );
                    }

                    flagUpdateBuffer = true;
                }

                hoveredItem = item;
                hoveredGroup = group;

                if (flagUpdateBuffer) {
                    renderer.updateData(buffersManager.getDataBuffer());
                }
            });
        })();
    })();

    return {
        state, events,
        buffersManager, renderer,
        initPromise, canvas,
        mapData,
        async loadMapData(
            url: string
        ): Promise<void> {
            await dataLoader_v1(
                url,
                mapData,
                buffersManager
            );
            renderer.updateData(
                buffersManager.getDataBuffer()
            );
        },
        helpers: {
            setColor(
                slot: number,
                color: string
            ): void {
                buffersManager.setColor(slot, color);
                renderer.updateColors(buffersManager.getColorBuffer());
                renderer.requestUpdate();
            }
        }
    }
}