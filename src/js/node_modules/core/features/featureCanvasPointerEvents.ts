import State from "core/State";
import Renderer from "core/Renderer";
import Events from "core/Events";

/******************************/

export default function featureCanvasPointerEvents(
    element: HTMLElement,
    renderer: Renderer,
    state: State,
    events: Events,
): void {
    let mouseState = {
        prev: [0, 0],
        prevTile: [0, 0],
        click: false,
        move: false
    };

    element.addEventListener('mousemove', (e: MouseEvent) => {
        state.setCursor(e.offsetX, e.offsetY);

        let [ x, y ] = state.getCursorTile();

        if (mouseState.click) {
            let diffX = mouseState.prev[0] - e.offsetX,
                diffY = mouseState.prev[1] - e.offsetY;

            if (diffX > 5 || diffX < -5
                || diffY > 5 || diffY < -5
            ) {
                mouseState.move = true;
                events.emit('map/move', true);
            }

            if (mouseState.move) {
                state.addPxPosition(diffX, diffY);
                renderer.setPosition(
                    ...state.getPosition()
                );

                mouseState.prev[0] = e.offsetX;
                mouseState.prev[1] = e.offsetY;
            }
        } else {
            if (mouseState.prevTile[0] !== x
                || mouseState.prevTile[1] !== y
            ) {
                mouseState.prevTile[0] = x;
                mouseState.prevTile[1] = y;
                events.emit('hover/map', { x, y });
            }
        }
    }, false);

    element.addEventListener('mousedown', (e: MouseEvent) => {
        mouseState.prev[0] = e.offsetX;
        mouseState.prev[1] = e.offsetY;
        mouseState.click = true;
    }, false);

    element.addEventListener('mouseup', (e: MouseEvent) => {
        if (mouseState.move) {
            events.emit('map/move', false);
        } else if (mouseState.click) {
            let [ x, y ] = mouseState.prevTile;

            events.emit('click/map', { x, y });
        }

        mouseState.click = false;
        mouseState.move = false;
    }, false);

    element.addEventListener('mouseenter', (e: MouseEvent) => {
        events.emit('map/enter');
    }, false);

    element.addEventListener('mouseleave', (e: MouseEvent) => {
        if (mouseState.move) {
            events.emit('map/move', false);
        }

        events.emit('map/leave');
        mouseState.click = false;
        mouseState.move = false;
    }, false);

    // wheel - zoom
    let wheelEvent = "onwheel" in HTMLDivElement.prototype
        ? "wheel"
        : document['onmousewheel'] !== undefined
            ? "mousewheel"
            : "DOMMouseScroll";

    element.addEventListener(wheelEvent, (e: MouseEvent) => {
        if (e['deltaY'] < 0) {
            state.multipleSizeSmooth(1 + 0.1);
        } else {
            state.multipleSizeSmooth(1 - 0.1);
        }
        renderer.setSize(state.getSize());
        requestAnimationFrame(animateSize);
    }, {
        capture: false,
        passive: true
    });

    function animateSize() {
        if (state.isSmoothSize()) {
            requestAnimationFrame(animateSize);
        }
        renderer.setSize(state.getSize());

        state.updateCursor();
        let [ x, y ] = state.getCursorTile();

        if (mouseState.prevTile[0] !== x
            || mouseState.prevTile[1] !== y
        ) {
            mouseState.prevTile[0] = x;
            mouseState.prevTile[1] = y;
            events.emit('hover/map', { x, y });
        }
    }

    // touch

    let touchState = {
        touch: false,
        multi: false,
        move: false,
        prev: {
            a: [0, 0],
            b: [0, 0]
        }
    };

    element.addEventListener("touchmove", (e: TouchEvent) => {
        let touch = e.touches[0];
        let secondTouch = e.touches[1];

        if (touchState.multi, secondTouch) {
            let prevValue
                = Math.pow(touchState.prev.a[0] - touchState.prev.b[0], 2)
                + Math.pow(touchState.prev.a[1] - touchState.prev.b[1], 2);
            let currentValue
                = Math.pow(touch.clientX - secondTouch.clientX, 2)
                + Math.pow(touch.clientY - secondTouch.clientY, 2);

            state.multipleSize((currentValue / prevValue) || 1);
            renderer.setSize(state.getSize());

            touchState.prev.a[0] = touch.clientX;
            touchState.prev.a[1] = touch.clientY;
            touchState.prev.b[0] = secondTouch.clientX;
            touchState.prev.b[1] = secondTouch.clientY;
        } else if (touchState.touch) {
            let diffX = touchState.prev.a[0] - touch.clientX,
                diffY = touchState.prev.a[1] - touch.clientY;

            if (diffX > 5 || diffX < -5
                || diffY > 5 || diffY < -5
            ) {
                touchState.move = true;
                events.emit('map/move', true);
            }

            if (touchState.move) {
                state.addPxPosition(diffX, diffY);
                renderer.setPosition(
                    ...state.getPosition()
                );

                touchState.prev.a[0] = touch.clientX;
                touchState.prev.a[1] = touch.clientY;
            }
        }

        e.preventDefault(); // android chrome :/
    }, {
        capture: false,
        passive: true
    });
    element.addEventListener("touchstart", (e: TouchEvent) => {
        touchState.touch = true;


        if (e.touches.length > 1) {
            let touch = e.touches[1];

            touchState.multi = true;
            touchState.prev.b[0] = touch.clientX;
            touchState.prev.b[1] = touch.clientY;
        } else {
            let touch = e.touches[0];

            touchState.prev.a[0] = touch.clientX;
            touchState.prev.a[1] = touch.clientY;
        }
    }, {
        capture: false,
        passive: true
    });
    element.addEventListener("touchend", (e: TouchEvent) => {
        if (e.touches.length === 2) {
            touchState.multi = false;
        } else {
            if (touchState.move) {
                events.emit('map/move', false);
            }
            touchState.touch = false;
            touchState.move = false;
        }
    }, {
        capture: false,
        passive: true
    });
    element.addEventListener("touchcancel", (e: TouchEvent) => {
        if (e.touches.length === 2) {
            touchState.multi = false;
        } else {
            if (touchState.move) {
                events.emit('map/move', false);
            }
            touchState.touch = false;
            touchState.move = false;
        }
    }, {
        capture: false,
        passive: true
    });
}