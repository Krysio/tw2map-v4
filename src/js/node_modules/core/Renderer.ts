function createShader(
    webGlContext: WebGLRenderingContext,
    type: number,
    source: string
): WebGLShader {
    let shader = webGlContext.createShader(type);

    webGlContext.shaderSource(shader, source);
    webGlContext.compileShader(shader);

    let success = webGlContext.getShaderParameter(
        shader,
        webGlContext.COMPILE_STATUS
    );

    if (success) {
        return shader;
    }

    console.log(`Shader {${ type }} error`);
    console.log(webGlContext.getShaderInfoLog(shader));
    webGlContext.deleteShader(shader);
}

function createProgram(
    webGlContext: WebGLRenderingContext,
    vertexShader: WebGLShader,
    fragmentShader: WebGLShader
): WebGLProgram {
    let program = webGlContext.createProgram();

    webGlContext.attachShader(program, vertexShader);
    webGlContext.attachShader(program, fragmentShader);
    webGlContext.linkProgram(program);

    let success = webGlContext.getProgramParameter(
        program,
        webGlContext.LINK_STATUS
    );

    if (success) {
        return program;
    }

    console.log(webGlContext.getProgramInfoLog(program));
    webGlContext.deleteProgram(program);
}

/******************************/

type TextureDataStructure = {
    slot: number,
    texture: WebGLTexture,
    uniformLocation: WebGLUniformLocation,
    unit: number
};

/******************************/

export default class Renderer {
    protected shaderProgram: WebGLShader;
    protected context: WebGLRenderingContext;
    protected textures: {
        data: TextureDataStructure,
        color: TextureDataStructure
    };
    protected uniforms: {
        position: WebGLUniformLocation,
        size: WebGLUniformLocation,
        time: WebGLUniformLocation,
        resolution: WebGLUniformLocation
    };
    protected requestUpdateLock = false;

    constructor(
        protected canvas: HTMLCanvasElement
    ) {
        this.context = canvas.getContext('webgl') as WebGLRenderingContext;

        this.animationFrame = this.animationFrame.bind(this);
    }

    async init(
        dataBuffer: Uint8Array,
        colorBuffer: Uint8Array
    ) {
        console.log('init:start');

        this.context.viewport(0, 0, this.canvas.width, this.canvas.height);
        this.context.clearColor(0, 0, 0, 0);
        this.context.clear(this.context.COLOR_BUFFER_BIT);

        await this.initShaders();

        this.initVerticles();
        this.initTextures(dataBuffer, colorBuffer);
        this.initUniforms();

        console.log('init:end');
    }

    async initShaders() {
        let vertexShaderSource = await (
                await fetch('glsl/vertex.glsl')
            ).text();
        let fragmentShaderSource = await (
                await fetch('glsl/fragment.glsl')
            ).text();

        let { VERTEX_SHADER, FRAGMENT_SHADER } = this.context;

        let vertexShader = createShader(
                this.context,
                VERTEX_SHADER,
                vertexShaderSource
            );
        let fragmentShader = createShader(
                this.context,
                FRAGMENT_SHADER,
                fragmentShaderSource
            );

        this.shaderProgram = createProgram(
            this.context,
            vertexShader,
            fragmentShader
        );
        this.context.useProgram(this.shaderProgram);
    }

    initVerticles(): void {
        let { ARRAY_BUFFER, STATIC_DRAW, FLOAT } = this.context;

        let positionBuffer = this.context.createBuffer();
        let positionAttributeLocation = this.context.getAttribLocation(
            this.shaderProgram,
            'vertexIndex'
        );

        this.context.bindBuffer(
            ARRAY_BUFFER,
            positionBuffer
        );
        this.context.bufferData(
            ARRAY_BUFFER,
            new Float32Array([0,1,2,3]),
            STATIC_DRAW
        );

        this.context.enableVertexAttribArray(
            positionAttributeLocation
        );
        this.context.vertexAttribPointer(
            positionAttributeLocation,
            1,          // size - 2 components per iteration
            FLOAT,      // type - the data is 32bit floats
            false,      // normalize - don't normalize the data
            0,          // stride - 0 = move forward size * sizeof(type) each iteration to get the next position
            0           // offset - start at the beginning of the buffer
        );
    }

    //https://webgl2fundamentals.org/webgl/lessons/webgl-data-textures.html
    initTextures(
        dataBuffer: Uint8Array,
        colorBuffer: Uint8Array
    ): void {
        let { TEXTURE0, TEXTURE1 } = this.context;

        this.textures = {
            data: {
                slot: TEXTURE0,
                unit: 0,
                texture: this.context.createTexture(),
                uniformLocation: this.context.getUniformLocation(
                    this.shaderProgram,
                    'iData'
                )
            },
            color: {
                slot: TEXTURE1,
                unit: 1,
                texture: this.context.createTexture(),
                uniformLocation: this.context.getUniformLocation(
                    this.shaderProgram,
                    'iColor'
                )
            }
        };

        let {
            TEXTURE_2D,
            RGB, RGBA,
            UNSIGNED_BYTE,
            TEXTURE_WRAP_S, TEXTURE_WRAP_T,
            TEXTURE_MAG_FILTER, TEXTURE_MIN_FILTER,
            REPEAT, NEAREST
        } = this.context;

        // data
        this.context.bindTexture(
            TEXTURE_2D,
            this.textures.data.texture
        );
        this.context.texImage2D(
            TEXTURE_2D, 0,
            RGB,
            2048, 1024, 0,
            RGB, UNSIGNED_BYTE,
            dataBuffer
        );
        this.context.texParameteri(TEXTURE_2D, TEXTURE_WRAP_S, REPEAT);
        this.context.texParameteri(TEXTURE_2D, TEXTURE_WRAP_T, REPEAT);
        this.context.texParameteri(TEXTURE_2D, TEXTURE_MAG_FILTER, NEAREST);
        this.context.texParameteri(TEXTURE_2D, TEXTURE_MIN_FILTER, NEAREST);
        this.context.uniform1i(
            this.textures.data.uniformLocation,
            this.textures.data.unit
        );

        // color
        this.context.bindTexture(
            TEXTURE_2D,
            this.textures.color.texture
        );
        this.context.texImage2D(
            TEXTURE_2D, 0,
            RGBA,
            256, 1, 0,
            RGBA, UNSIGNED_BYTE,
            colorBuffer
        );
        this.context.texParameteri(TEXTURE_2D, TEXTURE_WRAP_S, REPEAT);
        this.context.texParameteri(TEXTURE_2D, TEXTURE_WRAP_T, REPEAT);
        this.context.texParameteri(TEXTURE_2D, TEXTURE_MAG_FILTER, NEAREST);
        this.context.texParameteri(TEXTURE_2D, TEXTURE_MIN_FILTER, NEAREST);
        this.context.uniform1i(
            this.textures.color.uniformLocation,
            this.textures.color.unit
        );

        // active
        this.context.activeTexture(this.textures.data.slot);
        this.context.bindTexture(
            TEXTURE_2D,
            this.textures.data.texture
        );
        this.context.activeTexture(this.textures.color.slot);
        this.context.bindTexture(
            TEXTURE_2D,
            this.textures.color.texture
        );
    }

    initUniforms() {
        this.uniforms = {
            position: this.context.getUniformLocation(
                this.shaderProgram,
                'iPosition'
            ),
            size: this.context.getUniformLocation(
                this.shaderProgram,
                'iSize'
            ),
            time: this.context.getUniformLocation(
                this.shaderProgram,
                'iTime'
            ),
            resolution: this.context.getUniformLocation(
                this.shaderProgram,
                'iResolution'
            )
        }

        this.setSize(50);
        this.setPosition(0.5, 0.5);
        this.updateResolution();
    }

    /******************************/

    setSize(
        value: number
    ): void {
        this.context.uniform1f(this.uniforms.size, value);

        this.requestUpdate();
    }

    setPosition(
        valueX: number,
        valueY: number
    ): void {
        this.context.uniform2f(
            this.uniforms.position,
            valueX,
            valueY
        );

        this.requestUpdate();
    }

    updateResolution(): void {
        this.context.viewport(
            0,
            0,
            this.canvas.width,
            this.canvas.height
        );
        this.context.uniform2f(
            this.uniforms.resolution,
            this.canvas.width,
            this.canvas.height
        );

        this.requestUpdate();
    }

    /******************************/

    updateData(
        dataBuffer: Uint8Array
    ): void {
        let {
            TEXTURE_2D,
            RGB, UNSIGNED_BYTE
        } = this.context;

        this.context.activeTexture(this.textures.data.slot);
        this.context.bindTexture(
            TEXTURE_2D,
            this.textures.data.texture
        );
        this.context.texImage2D(
            TEXTURE_2D, 0,
            RGB,
            2048, 1024, 0,
            RGB, UNSIGNED_BYTE,
            dataBuffer
        );

        this.requestUpdate();
    }

    updateColors(
        colorBuffer: Uint8Array
    ): void {
        let {
            TEXTURE_2D,
            RGBA,
            UNSIGNED_BYTE
        } = this.context;

        this.context.activeTexture(this.textures.color.slot);
        this.context.bindTexture(
            TEXTURE_2D,
            this.textures.color.texture
        );
        this.context.texImage2D(
            TEXTURE_2D, 0,
            RGBA,
            256, 1, 0,
            RGBA, UNSIGNED_BYTE,
            colorBuffer
        );

        this.requestUpdate();
    }

    /******************************/

    requestUpdate() {
        if (!this.requestUpdateLock) {
            this.requestUpdateLock = true;
            requestAnimationFrame(this.animationFrame);
        }
    }
    protected animationFrame() {
        this.requestUpdateLock = false;
        this.context.uniform1f(
            this.uniforms.time,
            Date.now()
        );
        this.context.drawArrays(
            this.context.TRIANGLE_FAN, // primitiveType
            0, // offset,
            4 // count
        );
    }
}