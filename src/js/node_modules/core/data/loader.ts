import MapData from "./MapData";
import BuffersManager, {
    TILE_TYPE_BORDER,
    TILE_TYPE_BORDER_WATER
} from "core/BuffersManager";
import Character from "./objects/Character";
import Village from "./objects/Village";
import Tribe from "./objects/Tribe";

import {
    TILE_TYPE_VILLAGE,
    COLOR_INDEX_PLAYER_VILLAGE,
    COLOR_INDEX_BARBARIAN_VILLAGE
} from 'core/BuffersManager';

export async function dataLoader_v1(
    url: string,
    mapData: MapData,
    buffersManager: BuffersManager
) {
    let jsonData = await (
            await fetch(url)
        ).json();

    mapData.setDownloadTime(jsonData.time);

    // odczytywanie plemion i tworzenie obiektów
    for (let tribeId in jsonData.tribes) {
        let tribeData = jsonData.tribes[ tribeId ],
            tribe: Tribe = new Tribe();

        tribe.id = parseInt(tribeId);
        tribe.name = tribeData[0];
        tribe.tag = tribeData[1];
        tribe.points = parseInt(tribeData[2]);

        mapData.addTribe(tribe);
    }

    // odczytywanie graczy i tworzenie obiektów
    for (let characterId in jsonData.characters) {
        let characterData = jsonData.characters[ characterId ],
            character = new Character();

        character.id = parseInt(characterId);
        character.name = characterData[0];
        character.points = parseInt(characterData[1]);
        character.tribeId = parseInt(characterData[2]) || null;

        mapData.addCharacter(character);
    }

    // odczytywanie wiosek i tworzenie obiektów
    for (let villageId in jsonData.villages) {
        let villageData = jsonData.villages[ villageId ],
            village = new Village();

        village.id = parseInt(villageId);
        village.x = parseInt(villageData[0]);
        village.y = parseInt(villageData[1]);
        village.name = villageData[2];
        village.points = parseInt(villageData[3]);
        village.characterId = parseInt(villageData[4]) || null;

        mapData.addVillage(village);

        if (village.characterId) {
            buffersManager.tileSetColorSlot(
                village.x,
                village.y,
                COLOR_INDEX_PLAYER_VILLAGE
            );
        } else {
            buffersManager.tileSetColorSlot(
                village.x,
                village.y,
                COLOR_INDEX_BARBARIAN_VILLAGE
            );
        }
        buffersManager.tileSetType(
            village.x,
            village.y,
            TILE_TYPE_VILLAGE
        );
    }
}

export async function bitDataLoader_v1(
    url: string,
    buffersManager: BuffersManager
) {
    const MAP_SIZE = 1000;
    const TILE_COUNT = MAP_SIZE * MAP_SIZE;
    const BITS_IN_TILE_PER_BYTE = 5 / 8;

    let bgDataBuffer = await (
            await fetch(url)
        ).arrayBuffer();

    let dataView = new DataView(bgDataBuffer);

    for (let tilePos = 0; tilePos < TILE_COUNT; tilePos++) {
        let bytePosInSegment    = tilePos % 8,
            byteOffset          = (tilePos - bytePosInSegment) * BITS_IN_TILE_PER_BYTE,
            result;

        switch (bytePosInSegment) {
            case 0:
                result = (dataView.getUint8(byteOffset) >> 3);
                break;
            case 1:
                result = ((dataView.getUint8(byteOffset) << 2) + (dataView.getUint8(byteOffset + 1) >> 6));
                break;
            case 2:
                result = dataView.getUint8(byteOffset + 1) >> 1;
                break;
            case 3:
                result = ((dataView.getUint8(byteOffset + 1) << 4) + (dataView.getUint8(byteOffset + 2) >> 4));
                break;
            case 4:
                result = ((dataView.getUint8(byteOffset + 2) << 1) + (dataView.getUint8(byteOffset + 3) >> 7));
                break;
            case 5:
                result = (dataView.getUint8(byteOffset + 3) >> 2);
                break;
            case 6:
                result = ((dataView.getUint8(byteOffset + 3) << 3) + (dataView.getUint8(byteOffset + 4) >> 5));
                break;
            case 7:
                result = dataView.getUint8(byteOffset + 4);
                break;
        }

        result&= 31;

        if (result >>> 4) {
            let y = tilePos % MAP_SIZE,
                x = Math.floor(tilePos / MAP_SIZE);

            if ((result >> 2) & 1) {
                buffersManager.tileSetType(x, y, TILE_TYPE_BORDER);
            } else {
                buffersManager.tileSetType(x, y, TILE_TYPE_BORDER_WATER);
            }
        }
    }
}