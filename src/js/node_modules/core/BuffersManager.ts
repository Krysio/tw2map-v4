const BUFF_COLOR_COUNT = 256 * 256;
const BUFF_COLOR_VALUES_COUNT = 4;
const BUFF_DATA_COUNT = 1024 * 1024;
const BUFF_DATA_VALUES_COUNT = 6;

const REGE_IMPORT_VALUES_FROM_HEX_COLOR = /([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})/;

export const TILE_TYPE_VOID = 0;            // 00
export const TILE_TYPE_VILLAGE = 1;         // 01
export const TILE_TYPE_BORDER = 2;          // 10
export const TILE_TYPE_BORDER_WATER = 3;    // 11

export const COLOR_INDEX_BACKGROUND = 0;
export const COLOR_INDEX_BORDER = 1;
export const COLOR_INDEX_WATER = 2;
export const COLOR_INDEX_PLAYER_VILLAGE = 3;
export const COLOR_INDEX_BARBARIAN_VILLAGE = 4;
export const COLOR_INDEX_HOVER = 5;
export const COLOR_INDEX_GROUP_HOVER = 6;

/******************************/

export default class BuffersManager {
    protected dataBuffer: Uint8Array;
    protected colorBuffer: Uint8Array;
    protected nextSlotIndex: number = 0;

    init(): void {
        this.createDataBuffer();
        this.createColorBuffer();
    }

    /******************************/

    protected createDataBuffer(): Uint8Array {
        let dataBuffer = new Uint8Array(BUFF_DATA_COUNT * BUFF_DATA_VALUES_COUNT);

        for (var i = 0; i < BUFF_DATA_COUNT * BUFF_DATA_VALUES_COUNT; i+= BUFF_DATA_VALUES_COUNT) {
            dataBuffer[ i + 0 ] = COLOR_INDEX_BACKGROUND;
            dataBuffer[ 1 + 1 ] = 0;
            dataBuffer[ i + 2 ] = TILE_TYPE_VOID;
            dataBuffer[ 1 + 3 ] = COLOR_INDEX_BACKGROUND;
            dataBuffer[ i + 4 ] = 0;
            dataBuffer[ 1 + 5 ] = 0;
        }

        return this.dataBuffer = dataBuffer;
    }

    protected createColorBuffer(): Uint8Array {
        this.colorBuffer = new Uint8Array(BUFF_COLOR_COUNT * BUFF_COLOR_VALUES_COUNT);
        this.initDefaultColors();

        return this.colorBuffer;
    }

    protected initDefaultColors(): void {
        this.addColor('#004000'); // background
        this.addColor('#888888'); // border
        this.addColor('#ffff00'); // river
        this.addColor('#003000'); // player village
        this.addColor('#005000'); // barbarian village
        this.addColor('#ffffff'); // hover
        this.addColor('#999999'); // hover group
    }

    /******************************/

    /**
     * @param color Color in hex: '#aabbcc'
     * @return slot number
     */
    addColor(
        color: string
    ): number {
        let slot = Math.min(this.nextSlotIndex++, BUFF_COLOR_COUNT - 1);

        this.setColor(slot, color);

        return slot;
    }

    getColor (
        slot: number
    ): string {
        let validSlot = Math.max(0, Math.min(slot, BUFF_COLOR_COUNT - 1)),
            index = validSlot * BUFF_COLOR_VALUES_COUNT;

        return `#${ new Buffer([
            this.colorBuffer[ index + 0 ],
            this.colorBuffer[ index + 1 ],
            this.colorBuffer[ index + 2 ]
        ]).toString('hex') }`;
    }

    setColor(
        slot: number,
        color: string
    ): void {
        let validSlot = Math.max(0, Math.min(slot, BUFF_COLOR_COUNT - 1)),
            index = validSlot * BUFF_COLOR_VALUES_COUNT,
            colorValues = color.match(REGE_IMPORT_VALUES_FROM_HEX_COLOR);

        if (colorValues.length !== 4) {
            throw new Error('TODO: invalid color format');
        }

        this.colorBuffer[ index + 0 ] = parseInt(colorValues[1], 16);
        this.colorBuffer[ index + 1 ] = parseInt(colorValues[2], 16);
        this.colorBuffer[ index + 2 ] = parseInt(colorValues[3], 16);
        this.colorBuffer[ index + 3 ] = 1;
    }

    tileSetBgSlot(
        x: number,
        y: number,
        slot: number
    ): void {
        let index = y * 1024 * BUFF_DATA_VALUES_COUNT + x * BUFF_DATA_VALUES_COUNT,
            colorX = slot % 255,
            colorY = Math.floor(slot / 255);

        this.dataBuffer[ index + 0 ] = colorX;
        this.dataBuffer[ index + 1 ] = colorY;
    }

    tileSetColorSlot(
        x: number,
        y: number,
        slot: number
    ): void {
        let index = y * 1024 * BUFF_DATA_VALUES_COUNT + x * BUFF_DATA_VALUES_COUNT,
            colorX = slot % 255,
            colorY = Math.floor(slot / 255);

        this.dataBuffer[ index + 3 ] = colorX;
        this.dataBuffer[ index + 4 ] = colorY;
    }

    tileGetType(
        x: number,
        y: number,
    ): number {
        let index = y * 1024 * BUFF_DATA_VALUES_COUNT + x * BUFF_DATA_VALUES_COUNT;

        return this.dataBuffer[ index + 2 ];
    }
    tileSetType(
        x: number,
        y: number,
        type: number
    ): void {
        let index = y * 1024 * BUFF_DATA_VALUES_COUNT + x * BUFF_DATA_VALUES_COUNT;

        this.dataBuffer[ index + 2 ] = type;

        switch (type) {
            case TILE_TYPE_BORDER_WATER:
                this.dataBuffer[ index + 3 ] = COLOR_INDEX_BORDER;
                this.dataBuffer[ index + 4 ] = 0;
                break;
            case TILE_TYPE_BORDER:
                this.dataBuffer[ index + 3 ] = COLOR_INDEX_WATER;
                this.dataBuffer[ index + 4 ] = 0;
                break;
        }
    }

    /******************************/

    getDataBuffer(): Uint8Array {
        return this.dataBuffer;
    }

    getColorBuffer(): Uint8Array {
        return this.colorBuffer;
    }
}